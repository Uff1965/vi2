// This is an independent project of an individual developer. Dear PVS-Studio, please check it.
// PVS-Studio Static Code Analyzer for C, C++, C#, and Java: http://www.viva64.com

/*****************************************************************************\
* This file is part of the vi_timing library.
* 
* vi_timing - a compact, lightweight C/C++ library for measuring code 
* execution time. It was developed for experimental and educational purposes, 
* so please keep expectations reasonable.
*
* Report bugs or suggest improvements to author: <programmer.amateur@proton.me>
*
* LICENSE & DISCLAIMER:
* - No warranties. Use at your own risk.
* - Licensed under Business Source License 1.1 (BSL-1.1):
*   - Free for non-commercial use.
*   - For commercial licensing, contact the author.
*   - Change Date: 2029-09-01 - after which the library will be licensed 
*     under GNU GPLv3.
*   - Attribution required: "vi_timing Library © A.Prograamar".
*   - See LICENSE in the project root for full terms.
\*****************************************************************************/

#include "version.h"

#include <array>
#include <cassert>
#include <string_view>

namespace
{
	constexpr auto to_month(const char *str)
	{	// Converts a three-character month abbreviation to a number in the range 1..12.
		// 7.27.3.1 The asctime function. [C17 ballot ISO/IEC 9899:2017]
		constexpr std::array<std::string_view, 13> month_names
		{	"???", "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
		};
		auto month = month_names.size();
		while (0 != --month && 0 != month_names[month].compare(0, 3, str, 3))
		{/**/}
		assert(month); // Month must be in the range 1..12.
		return static_cast<std::uint32_t>(month);
	}

	constexpr std::uint32_t c2d(char c)
	{	// Converts a character to a digit, returning 0 for space.
		assert('0' <= c && c <= '9' || c == ' ');
		return c == ' ' ? 0U : c - '0';
	};

	constexpr std::uint32_t to_num(const char *str)
	{	// Converts a two-character string to a number, assuming the first character is a digit and the second is a digit or space.
		auto dec = 10U * c2d(*str);
		return dec + c2d(*++str);
	};

	// The time_stamp function converts date and time strings in the __DATE__ and __TIME__ formats to
	// a number representing a timestamp in the YYMMDDhhmm format.
	constexpr std::uint32_t time_stamp(const char (&date)[12], const char (&time)[9])
	{	// "__DATE__ <...> a character string literal of the form 'Mmm dd yyyy'" [15.11 Predefined macro names ISO/IEC JTC1 SC22 WG21 N4860]
		assert(0 == date[11] && date[3] == ' ' && date[6] == ' '); // The date must be in the __DATE__ macro format.
		constexpr auto POS_DECADES = 9U;
		constexpr auto POS_MONTHS = 0U;
		constexpr auto POS_DATES = 4U;
		const auto year = to_num(&date[POS_DECADES]);
		assert(year < 43U); // Time coding up to 23:59 on Dec 31 2042 is permitted.
		const auto month = to_month(&date[POS_MONTHS]);
		assert(month > 0 && month <= 12);
		const auto day = to_num(&date[POS_DATES]);
		assert(day > 0 && day <= 31);

		// "__TIME__ <...> a character string literal of the form 'hh:mm:ss' as in the time generated by the asctime function."
		assert(0 == time[8] && time[2] == ':' && time[5] == ':'); // The time must be in the __TIME__ macro format.
		constexpr auto POS_HOURS = 0U;
		constexpr auto POS_MINUTES = 3U;
		const auto hour = to_num(&time[POS_HOURS]);
		assert(hour >= 0 && hour < 24);
		const auto minute = to_num(&time[POS_MINUTES]);
		assert(minute >= 0 && minute < 60);

		return(100U * (100U * (100U * (100U * year + month) + day) + hour) + minute);
	}

	static_assert(time_stamp("Jun 17 2025", "09:33:00") == 2506170933U, "time_stamp() is not working correctly.");

	std::uint32_t build_number = 0U; // build_number is initialized by the compilation time of the last unit of translation in the YYMMDDhhmm format.
}

std::uint32_t misc::build_number_updater(const char (&date)[12], const char (&time)[9])
{	build_number = std::max(build_number, time_stamp(date, time));
	return build_number;
}

std::uint32_t misc::build_number_get()
{	return build_number;
}
